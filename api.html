<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>API Reference &#8212; pymer4 0.7.1.dev2 documentation</title>
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="_static/gallery-dataframe.css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Citation" href="citation.html" />
    <link rel="prev" title="Lme4 Random Effects Cheat Sheet" href="rfx_cheatsheet.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="_static/js/jquery-1.12.4.min.js "></script>
<script type="text/javascript" src="_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="_static/bootstrap-3.4.1/js/bootstrap.min.js "></script>
<script type="text/javascript" src="_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          Pymer4</a>
        <span class="navbar-text navbar-version pull-left"><b>0.7.1.dev2</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="auto_examples/index.html">Tutorial</a></li>
                <li><a href="#">API</a></li>
                <li><a href="https://github.com/ejolly/pymer4">Github</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Nav <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="new.html">What's New</a></li>
<li class="toctree-l1"><a class="reference internal" href="auto_examples/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="rfx_cheatsheet.html">Lme4 RFX Cheatsheet</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="citation.html">Citation</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">TOC <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">API Reference</a><ul>
<li><a class="reference internal" href="#pymer4-models-lmer-lmer"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymer4.models.Lmer</span></code>: Lmer</a></li>
<li><a class="reference internal" href="#pymer4-models-lm-lm"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymer4.models.Lm</span></code>: Lm</a></li>
<li><a class="reference internal" href="#pymer4-models-lm2-lm2"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymer4.models.Lm2</span></code>: Lm2</a></li>
<li><a class="reference internal" href="#pymer4-simulate-simulation-functions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymer4.simulate</span></code>: Simulation Functions</a></li>
<li><a class="reference internal" href="#pymer4-stats-statistics-functions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymer4.stats</span></code>: Statistics Functions</a></li>
<li><a class="reference internal" href="#pymer4-utils-utility-functions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymer4.utils</span></code>: Utility Functions</a></li>
<li><a class="reference internal" href="#pymer4-io-save-load-functions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymer4.io</span></code>: Save/Load Functions</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="pymer4-models-lmer-lmer">
<h2><a class="reference internal" href="#pymer4.models.Lmer" title="pymer4.models.Lmer"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymer4.models.Lmer</span></code></a>: Lmer<a class="headerlink" href="#pymer4-models-lmer-lmer" title="Permalink to this headline">¶</a></h2>
<p>Model class for estimating <code class="code docutils literal notranslate"><span class="pre">lme4</span></code> multi-level models in python</p>
<dl class="py class">
<dt id="pymer4.models.Lmer">
<em class="property">class </em><code class="sig-prename descclassname">pymer4.models.</code><code class="sig-name descname">Lmer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">formula</span></em>, <em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">family</span><span class="o">=</span><span class="default_value">'gaussian'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/models/Lmer.html#Lmer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.models.Lmer" title="Permalink to this definition">¶</a></dt>
<dd><p>Model class to hold data outputted from fitting lmer in R and converting to Python object. This class stores as much information as it can about a merMod object computed using lmer and lmerTest in R. Most attributes will not be computed until the fit method is called.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>formula</strong> (<em>str</em>) – Complete lmer-style model formula</p></li>
<li><p><strong>data</strong> (<em>pandas.core.frame.DataFrame</em>) – input data</p></li>
<li><p><strong>family</strong> (<em>string</em>) – what distribution family (i.e.) link function to use for the generalized model; default is gaussian (linear model)</p></li>
</ul>
</dd>
<dt class="field-even">Variables</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>fitted</strong> (<em>bool</em>) – whether model has been fit</p></li>
<li><p><strong>formula</strong> (<em>str</em>) – model formula</p></li>
<li><p><strong>data</strong> (<em>pd.DataFrame</em>) – model copy of input data</p></li>
<li><p><strong>grps</strong> (<em>dict</em>) – groups and number of observations per groups recognized by lmer</p></li>
<li><p><strong>design_matrix</strong> (<em>pd.DataFrame</em>) – model design matrix determined by lmer</p></li>
<li><p><strong>AIC</strong> (<em>float</em>) – model akaike information criterion</p></li>
<li><p><strong>logLike</strong> (<em>float</em>) – model Log-likelihood</p></li>
<li><p><strong>family</strong> (<em>string</em>) – model family</p></li>
<li><p><strong>warnings</strong> (<em>list</em>) – warnings output from R or Python</p></li>
<li><p><strong>ranef</strong> (<em>pd.DataFrame/list</em>) – cluster-level differences from population parameters, i.e. difference between coefs and fixefs; returns list if multiple cluster variables are used to specify random effects (e.g. subjects and items)</p></li>
<li><p><strong>fixef</strong> (<em>pd.DataFrame/list</em>) – cluster-level parameters; returns list if multiple cluster variables are used to specify random effects (e.g. subjects and items)</p></li>
<li><p><strong>coefs</strong> (<em>pandas.core.frame.DataFrame/list</em>) – model summary table of population parameters</p></li>
<li><p><strong>ranef_var</strong> (<em>pd.DataFrame</em>) – random effects variances</p></li>
<li><p><strong>ranef_corr</strong> (<em>pd.DataFrame</em>) – random effects correlations</p></li>
<li><p><strong>residuals</strong> (<em>numpy.ndarray</em>) – model residuals</p></li>
<li><p><strong>fits</strong> (<em>numpy.ndarray</em>) – model fits/predictions</p></li>
<li><p><strong>model_obj</strong> (<em>lmer model</em>) – rpy2 lmer model object</p></li>
<li><p><strong>factors</strong> (<em>dict</em>) – factors used to fit the model if any</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="pymer4.models.Lmer.anova">
<code class="sig-name descname">anova</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">force_orthogonal</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/models/Lmer.html#Lmer.anova"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.models.Lmer.anova" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a type-3 ANOVA table from a fitted model. Like R, this method does not ensure that contrasts are orthogonal to ensure correct type-3 SS computation. However, the force_orthogonal flag can refit the regression model with orthogonal polynomial contrasts automatically guaranteeing valid SS type 3 inferences. Note that this will overwrite factors specified in the last call to <cite>.fit()</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>force_orthogonal</strong> (<em>bool</em>) – whether factors in the model should be recoded using polynomial contrasts to ensure valid type-3 SS calculations. If set to True, previous factor specifications will be saved in <cite>model.factors_prev_</cite>; default False</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Type 3 ANOVA results</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pymer4.models.Lmer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">conf_int</span><span class="o">=</span><span class="default_value">'Wald'</span></em>, <em class="sig-param"><span class="n">n_boot</span><span class="o">=</span><span class="default_value">500</span></em>, <em class="sig-param"><span class="n">factors</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">permute</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ordered</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">REML</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">rank</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">rank_group</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">rank_exclude_cols</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">no_warnings</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">control</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">old_optimizer</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/models/Lmer.html#Lmer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.models.Lmer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Main method for fitting model object. Will modify the model’s data attribute to add columns for residuals and fits for convenience. Factors should be specified as a dictionary with values as a list or themselves a dictionary of <em>human readable</em> contrasts <em>not</em> R-style contrast codes as these will be auto-converted for you. See the factors docstring and examples below. After fitting, the .factors attribute will store a reference to the user-specified dictionary. The .contrast_codes model attributes will store the requested comparisons in converted R format. Note that Lmer estimate naming conventions differs a bit from R: Lmer.coefs = summary(model); Lmer.fixefs = coefs(model); Lmer.ranef = ranef(model)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>conf_int</strong> (<em>str</em>) – which method to compute confidence intervals; ‘profile’, ‘Wald’ (default), or ‘boot’ (parametric bootstrap)</p></li>
<li><p><strong>n_boot</strong> (<em>int</em>) – number of bootstrap intervals if bootstrapped confidence intervals are requests; default 500</p></li>
<li><p><strong>factors</strong> (<em>dict</em>) – dictionary with column names specified as keys and values as a list for dummy/treatment/polynomial contrast or a dict with keys as factor leves and values as desired comparisons in human readable format See examples below</p></li>
<li><p><strong>permute</strong> (<em>int</em>) – if non-zero, computes parameter significance tests by permuting test stastics rather than parametrically. Permutation is done by shuffling observations within clusters to respect random effects structure of data.</p></li>
<li><p><strong>ordered</strong> (<em>bool</em>) – whether factors should be treated as ordered polynomial contrasts; this will parameterize a model with K-1 orthogonal polynomial regressors beginning with a linear contrast based on the factor order provided; default is False</p></li>
<li><p><strong>summarize/summary</strong> (<em>bool</em>) – whether to print a model summary after fitting; default is True</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – whether to print when and which model and confidence interval are being fitted</p></li>
<li><p><strong>REML</strong> (<em>bool</em>) – whether to fit using restricted maximum likelihood estimation instead of maximum likelihood estimation; default True</p></li>
<li><p><strong>rank</strong> (<em>bool</em>) – covert predictors in model formula to ranks by group prior to estimation. Model object will still contain original data not ranked data; default False</p></li>
<li><p><strong>rank_group</strong> (<em>str</em>) – column name to group data on prior to rank conversion</p></li>
<li><p><strong>rank_exclude_cols</strong> (<em>list/str</em>) – columns in model formula to not apply rank conversion to</p></li>
<li><p><strong>no_warnings</strong> (<em>bool</em>) – turn off auto-printing warnings messages; warnings are always stored in the .warnings attribute; default False</p></li>
<li><p><strong>control</strong> (<em>str</em>) – string containing options to be passed to (g)lmer control. See <a class="reference external" href="https://bit.ly/2OQONTH">https://bit.ly/2OQONTH</a> for options</p></li>
<li><p><strong>old_optimizer</strong> (<em>bool</em>) – use the old bobyqa optimizer that was the default in lmer4 &lt;= 1.1_20, i.e. prior to 02/04/2019. This is not compatible with the control setting as it’s meant to be a quick shorthand (e.g. to reproduce previous model results). However, the same setting can be manually requested using the control option if preferred. (For optimizer change discussions see: <a class="reference external" href="https://bit.ly/2MrP9Nq">https://bit.ly/2MrP9Nq</a> and <a class="reference external" href="https://bit.ly/2Vx5jte">https://bit.ly/2Vx5jte</a> )</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>R/statsmodels style summary</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The following examples demonstrate how to treat variables as categorical factors.</p>
<p>Dummy-Coding: Treat Col1 as a factor which 3 levels: A, B, C. Use dummy-coding with A as the reference level. Model intercept will be mean of A, and parameters will be B-A, and C-A.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">factors</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Col1&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;C&#39;</span><span class="p">]})</span>
</pre></div>
</div>
<p>Orthogonal Polynomials: Treat Col1 as a factor which 3 levels: A, B, C. Estimate a linear contrast of C &gt; B &gt; A. Model intercept will be grand-mean of all levels, and parameters will be linear contrast, and orthogonal polynomial contrast (auto-computed).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">factors</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Col1&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;C&#39;</span><span class="p">]},</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Custom-contrast: Treat Col1 as a factor which 3 levels: A, B, C. Compare A to the mean of B and C. Model intercept will be the grand-mean of all levels, and parameters will be the desired contrast, a well as an automatically determined orthogonal contrast.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">factors</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Col1&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="o">-.</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="o">-.</span><span class="mi">5</span><span class="p">}}))</span>
</pre></div>
</div>
<p>Here is an example specifying stricter deviance and paramter values stopping criteria.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">control</span><span class="o">=</span><span class="s2">&quot;optCtrl = list(ftol_abs=1e-8, xtol_abs=1e-8)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here is an example specifying a different optimizer in addition to stricter deviance and paramter values stopping criteria.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">control</span><span class="o">=</span><span class="s2">&quot;optimizer=&#39;Nelder_Mead&#39;, optCtrl = list(FtolAbs=1e-8, XtolRel=1e-8)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here is an example using the default optimization in previous versions of lme4 prior to the 2019 update.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">old_optimizer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pymer4.models.Lmer.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">param</span></em>, <em class="sig-param"><span class="n">figsize</span><span class="o">=</span><span class="default_value">8, 6</span></em>, <em class="sig-param"><span class="n">xlabel</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">ylabel</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">plot_fixef</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">plot_ci</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">grps</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">ax</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/models/Lmer.html#Lmer.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.models.Lmer.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot random and group level parameters from a fitted model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>param</strong> (<em>str</em>) – model parameter (column name) to plot</p></li>
<li><p><strong>figsize</strong> (<em>tup</em>) – matplotlib desired figsize</p></li>
<li><p><strong>xlabel</strong> (<em>str</em>) – x-axis label</p></li>
<li><p><strong>ylabel</strong> (<em>str</em>) – y-axis label</p></li>
<li><p><strong>plot_fixef</strong> (<em>bool</em>) – plot population effect fit of param?; default True</p></li>
<li><p><strong>plot_ci</strong> (<em>bool</em>) – plot computed ci’s of population effect?; default True</p></li>
<li><p><strong>grps</strong> (<em>list</em>) – plot specific group fits only; must correspond to index values in model.fixef</p></li>
<li><p><strong>ax</strong> (<em>matplotlib.axes.Axes</em>) – axis handle for an existing plot; if provided will ensure that random parameter plots appear <em>behind</em> all other plot objects.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>matplotlib axis handle</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>plt.axis</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pymer4.models.Lmer.plot_summary">
<code class="sig-name descname">plot_summary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">figsize</span><span class="o">=</span><span class="default_value">12, 6</span></em>, <em class="sig-param"><span class="n">error_bars</span><span class="o">=</span><span class="default_value">'ci'</span></em>, <em class="sig-param"><span class="n">ranef</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">axlim</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">plot_intercept</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">ranef_alpha</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">coef_fmt</span><span class="o">=</span><span class="default_value">'o'</span></em>, <em class="sig-param"><span class="n">orient</span><span class="o">=</span><span class="default_value">'v'</span></em>, <em class="sig-param"><span class="n">ranef_idx</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/models/Lmer.html#Lmer.plot_summary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.models.Lmer.plot_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a forestplot overlaying estimated coefficients with random effects (i.e. BLUPs). By default display the 95% confidence intervals computed during fitting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>error_bars</strong> (<em>str</em>) – one of ‘ci’ or ‘se’ to change which error bars are plotted; default ‘ci’</p></li>
<li><p><strong>ranef</strong> (<em>bool</em>) – overlay BLUP estimates on figure; default True</p></li>
<li><p><strong>axlim</strong> (<em>tuple</em>) – lower and upper limit of plot; default min and max of BLUPs</p></li>
<li><p><strong>plot_intercept</strong> (<em>bool</em>) – plot the intercept estimate; default True</p></li>
<li><p><strong>ranef_alpha</strong> (<em>float</em>) – opacity of random effect points; default .5</p></li>
<li><p><strong>coef_fmt</strong> (<em>str</em>) – matplotlib marker style for population coefficients</p></li>
<li><p><strong>ranef_idx</strong> (<em>int</em>) – if multiple random effects clusters were specified this value indicates which one should be plotted; uses 0-based indexing; default 0 (first)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>matplotlib axis handle</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>plt.axis</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pymer4.models.Lmer.post_hoc">
<code class="sig-name descname">post_hoc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">marginal_vars</span></em>, <em class="sig-param"><span class="n">grouping_vars</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">p_adjust</span><span class="o">=</span><span class="default_value">'tukey'</span></em>, <em class="sig-param"><span class="n">summarize</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/models/Lmer.html#Lmer.post_hoc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.models.Lmer.post_hoc" title="Permalink to this definition">¶</a></dt>
<dd><p>Post-hoc pair-wise tests corrected for multiple comparisons (Tukey method) implemented using the emmeans package. This method provide both marginal means/trends along with marginal pairwise differences. More info can be found at: <a class="reference external" href="https://cran.r-project.org/web/packages/emmeans/emmeans.pdf">https://cran.r-project.org/web/packages/emmeans/emmeans.pdf</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>marginal_var</strong> (<em>str/list</em>) – what variable(s) to compute marginal means/trends for; unique combinations of factor levels of these variable(s) will determine family-wise error correction</p></li>
<li><p><strong>grouping_vars</strong> (<em>str/list</em>) – what variable(s) to group on. Trends/means/comparisons of other variable(s), will be computed at each level of these variable(s)</p></li>
<li><p><strong>p_adjust</strong> (<em>str</em>) – multiple comparisons adjustment method. One of: tukey, bonf, fdr, hochberg, hommel, holm, dunnet, mvt (monte-carlo multi-variate T, aka exact tukey/dunnet). Default tukey</p></li>
<li><p><strong>summarize</strong> (<em>bool</em>) – output effects and contrasts or don’t (always stored in model object as model.marginal_estimates and model.marginal_contrasts); default True</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – whether to print R messages to the console</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>marginal_estimates</strong> (<em>pd.Dataframe</em>): unique factor level effects (e.g. means/coefs)</p></li>
<li><p><strong>marginal_contrasts</strong> (<em>pd.DataFrame</em>): contrasts between factor levels</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Multiple</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Pairwise comparison of means of A at each level of B</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">post_hoc</span><span class="p">(</span><span class="n">marginal_vars</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="n">grouping_vars</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Pairwise differences of slopes of C between levels of A at each level of B</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">post_hoc</span><span class="p">(</span><span class="n">marginal_vars</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="n">grouping_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Pairwise differences of each unique A,B cell</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">post_hoc</span><span class="p">(</span><span class="n">marginal_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pymer4.models.Lmer.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">use_rfx</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">pred_type</span><span class="o">=</span><span class="default_value">'response'</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/models/Lmer.html#Lmer.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.models.Lmer.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Make predictions given new data. Input must be a dataframe that contains the same columns as the model.matrix excluding the intercept (i.e. all the predictor variables used to fit the model). If using random effects to make predictions, input data must also contain a column for the group identifier that were used to fit the model random effects terms. Using random effects to make predictions only makes sense if predictions are being made about the same groups/clusters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>pandas.core.frame.DataFrame</em>) – input data to make predictions on</p></li>
<li><p><strong>use_rfx</strong> (<em>bool</em>) – whether to condition on random effects when making predictions</p></li>
<li><p><strong>pred_type</strong> (<em>str</em>) – whether the prediction should be on the ‘response’ scale (default); or on the ‘link’ scale of the predictors passed through the link function (e.g. log-odds scale in a logit model instead of probability values)</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – whether to print R messages to console</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>prediction values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pymer4.models.Lmer.simulate">
<code class="sig-name descname">simulate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_datasets</span></em>, <em class="sig-param"><span class="n">use_rfx</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/models/Lmer.html#Lmer.simulate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.models.Lmer.simulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate new responses based upon estimates from a fitted model. By default group/cluster means for simulated data will match those of the original data. Unlike predict, this is a non-deterministic operation because lmer will sample random-efects values for all groups/cluster and then sample data points from their respective conditional distributions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_datasets</strong> (<em>int</em>) – number of simulated datasets to generate. Each simulation always generates a dataset that matches the size of the original data</p></li>
<li><p><strong>use_rfx</strong> (<em>bool</em>) – wehther to match group/cluster means in simulated data</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – whether to print R messages to console</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>simulated data values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pymer4.models.Lmer.summary">
<code class="sig-name descname">summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/models/Lmer.html#Lmer.summary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.models.Lmer.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Summarize the output of a fitted model.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>R/statsmodels style summary</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pd.DataFrame</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pymer4-models-lm-lm">
<h2><a class="reference internal" href="#pymer4.models.Lm" title="pymer4.models.Lm"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymer4.models.Lm</span></code></a>: Lm<a class="headerlink" href="#pymer4-models-lm-lm" title="Permalink to this headline">¶</a></h2>
<p>Model class for estimating standard regression models</p>
<dl class="py class">
<dt id="pymer4.models.Lm">
<em class="property">class </em><code class="sig-prename descclassname">pymer4.models.</code><code class="sig-name descname">Lm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">formula</span></em>, <em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">family</span><span class="o">=</span><span class="default_value">'gaussian'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/models/Lm.html#Lm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.models.Lm" title="Permalink to this definition">¶</a></dt>
<dd><p>Model class to perform OLS regression. Formula specification works just like in R based on columns of a dataframe. Formulae are parsed by patsy which makes it easy to utilize specifiy columns as factors. This is <strong>different</strong> from Lmer. See patsy for more information on the different use cases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>formula</strong> (<em>str</em>) – Complete lm-style model formula</p></li>
<li><p><strong>data</strong> (<em>pandas.core.frame.DataFrame</em>) – input data</p></li>
<li><p><strong>family</strong> (<em>string</em>) – what distribution family (i.e.) link function to use for the generalized model; default is gaussian (linear model)</p></li>
</ul>
</dd>
<dt class="field-even">Variables</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>fitted</strong> (<em>bool</em>) – whether model has been fit</p></li>
<li><p><strong>formula</strong> (<em>str</em>) – model formula</p></li>
<li><p><strong>data</strong> (<em>pd.DataFrame</em>) – model copy of input data</p></li>
<li><p><strong>design_matrix</strong> (<em>pd.DataFrame</em>) – model design matrix determined by patsy</p></li>
<li><p><strong>AIC</strong> (<em>float</em>) – model akaike information criterion</p></li>
<li><p><strong>logLike</strong> (<em>float</em>) – model Log-likelihood</p></li>
<li><p><strong>family</strong> (<em>string</em>) – model family</p></li>
<li><p><strong>warnings</strong> (<em>list</em>) – warnings output from Python</p></li>
<li><p><strong>coefs</strong> (<em>pd.DataFrame</em>) – model summary table of parameters</p></li>
<li><p><strong>residuals</strong> (<em>numpy.ndarray</em>) – model residuals</p></li>
<li><p><strong>fits</strong> (<em>numpy.ndarray</em>) – model fits/predictions</p></li>
<li><p><strong>estimator</strong> (<em>string</em>) – ‘OLS’ or ‘WLS’</p></li>
<li><p><strong>se_type</strong> (<em>string</em>) – how standard errors are computed</p></li>
<li><p><strong>sig_type</strong> (<em>string</em>) – how inference is performed</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="pymer4.models.Lm.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">robust</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">conf_int</span><span class="o">=</span><span class="default_value">'standard'</span></em>, <em class="sig-param"><span class="n">permute</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">rank</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">n_boot</span><span class="o">=</span><span class="default_value">500</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">n_lags</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">cluster</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wls_dof_correction</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/models/Lm.html#Lm.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.models.Lm.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a variety of OLS models. By default will fit a model that makes parametric assumptions (under a t-distribution) replicating the output of software like R. 95% confidence intervals (CIs) are also estimated parametrically by default. However, empirical bootstrapping can also be used to compute CIs; this procedure resamples with replacement from the data themselves, not residuals or data generated from fitted parameters and will be used for inference unless permutation tests are requested. Permutation testing will shuffle observations to generate a null distribution of t-statistics to perform inference on each regressor (permuted t-test).</p>
<p>Alternatively, OLS robust to heteroscedasticity can be fit by computing sandwich standard error estimates (good ref: <a class="reference external" href="https://bit.ly/2VRb7jK">https://bit.ly/2VRb7jK</a>). This is similar to Stata’s robust routine. Of the choices below, ‘hc1’ or ‘hc3’ are amongst the more popular.
Robust estimators include:</p>
<ul class="simple">
<li><p>‘hc0’: Huber (1967) original sandwich estimator</p></li>
<li><p>‘hc1’: Hinkley (1977) DOF adjustment to ‘hc0’ to account for small sample sizes (default)</p></li>
<li><p>‘hc2’: different kind of small-sample adjustment of ‘hc0’ by leverage values in hat matrix</p></li>
<li><p>‘hc3’: MacKinnon and White (1985) HC3 sandwich estimator; provides more robustness in smaller samples than hc2, Long &amp; Ervin (2000)</p></li>
<li><p>‘hac’: Newey-West (1987) estimator for robustness to heteroscedasticity as well as serial auto-correlation at given lags.</p></li>
<li><p>‘cluster’ : cluster-robust standard errors (see Cameron &amp; Miller 2015 for review). Provides robustness to errors that cluster according to specific groupings (e.g. repeated observations within a person/school/site). This acts as post-modeling “correction” for what a multi-level model explicitly estimates and is popular in the econometrics literature. DOF correction differs slightly from stat/statsmodels which use num_clusters - 1, where as pymer4 uses num_clusters - num_coefs</p></li>
</ul>
<p>Finally, weighted-least-squares (WLS) can be computed as an alternative to to hetereoscedasticity robust standard errors. This can be estimated by providing an array or series of weights (1 / variance of each group) with the same length as the number of observations or a column to use to compute group variances (which can be the same as the predictor column). This is often useful if some predictor(s) is categorical (e.g. dummy-coded) and taking into account unequal group variances is desired (i.e. in the simplest case this would be equivalent to peforming Welch’s t-test).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>robust</strong> (<em>bool/str</em>) – whether to use heteroscedasticity robust s.e. and optionally which estimator type to use (‘hc0’,’hc1’, ‘hc2’, hc3’,’hac’,’cluster’). If robust = True, default robust estimator is ‘hc1’; default False</p></li>
<li><p><strong>conf_int</strong> (<em>str</em>) – whether confidence intervals should be computed through bootstrap (‘boot’) or assuming a t-distribution (‘standard’); default ‘standard’</p></li>
<li><p><strong>permute</strong> (<em>int</em>) – if non-zero, computes parameter significance tests by permuting t-stastics rather than parametrically; works with robust estimators</p></li>
<li><p><strong>rank</strong> (<em>bool</em>) – convert all predictors and dependent variable to ranks before estimating model; default False</p></li>
<li><p><strong>summarize</strong> (<em>bool</em>) – whether to print a model summary after fitting; default True</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – whether to print which model, standard error, confidence interval, and inference type are being fitted</p></li>
<li><p><strong>n_boot</strong> (<em>int</em>) – how many bootstrap resamples to use for confidence intervals (ignored unless conf_int=’boot’)</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – number of cores for parallelizing bootstrapping or permutations; default 1</p></li>
<li><p><strong>n_lags</strong> (<em>int</em>) – number of lags for robust estimator type ‘hac’ (ignored unless robust=’hac’); default 1</p></li>
<li><p><strong>cluster</strong> (<em>str</em>) – column name identifying clusters/groups for robust estimator type ‘cluster’ (ignored unless robust=’cluster’)</p></li>
<li><p><strong>weights</strong> (<em>string/pd.Series/np.ndarray</em>) – weights to perform WLS instead of OLS. Pass in a column name in data to use to compute group variances and automatically adjust dof. Otherwise provide an array or series containing 1 / variance of each observation, in which case dof correction will not occur.</p></li>
<li><p><strong>wls_dof_correction</strong> (<em>bool</em>) – whether to apply Welch-Satterthwaite approximate correction for dof when using weights based on an existing column in the data, ignored otherwise. Set to False to force standard dof calculation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>R/statsmodels style summary</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Simple multiple regression model with parametric assumptions</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">Lm</span><span class="p">(</span><span class="s1">&#39;DV ~ IV1 + IV2&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
</pre></div>
</div>
<p>Same as above but with robust standard errors</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">robust</span><span class="o">=</span><span class="s1">&#39;hc1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Same as above but with cluster-robust standard errors. The cluster argument should refer to a column in the dataframe.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">robust</span><span class="o">=</span><span class="s1">&#39;cluster&#39;</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="s1">&#39;Group&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Simple regression with categorical predictor, i.e. between groups t-test assuming equal variances</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">Lm</span><span class="p">(</span><span class="s1">&#39;DV ~ Group&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
</pre></div>
</div>
<p>Same as above but don’t assume equal variances and have pymer4 compute the between group variances automatically, i.e. WLS (preferred).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="s1">&#39;Group&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Manually compute the variance of each group and use the inverse of that as the weights. In this case WLS is estimated but dof correction won’t be applied because it’s not trivial to compute.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;Group&quot;</span><span class="p">)[</span><span class="s1">&#39;DV&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">,</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">model.fit(weights=weights)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pymer4.models.Lm.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/models/Lm.html#Lm.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.models.Lm.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Make predictions given new data. Input must be a dataframe that contains the same columns as the model.matrix excluding the intercept (i.e. all the predictor variables used to fit the model). Will automatically use/ignore intercept to make a prediction if it was/was not part of the original fitted model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>pd.DataFrame</em>) – input data to make predictions on</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>prediction values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pymer4.models.Lm.summary">
<code class="sig-name descname">summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/models/Lm.html#Lm.summary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.models.Lm.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Summarize the output of a fitted model.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>R/statsmodels style summary</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pd.DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pymer4.models.Lm.to_corrs">
<code class="sig-name descname">to_corrs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">corr_type</span><span class="o">=</span><span class="default_value">'semi'</span></em>, <em class="sig-param"><span class="n">ztrans_corrs</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/models/Lm.html#Lm.to_corrs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.models.Lm.to_corrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform fitted model coefficients (excluding the intercept) to partial or semi-partial correlations with dependent variable. The is useful for rescaling coefficients to a correlation scale (-1 to 1) and does <strong>not</strong> change how inferences are performed. Semi-partial correlations are computed as the correlation between a DV and each predictor <em>after</em> the influence of all other predictors have been regressed out from that predictor. They are interpretable in the same way as the original coefficients. Partial correlations reflect the unique variance a predictor explains in the DV accounting for correlations between predictors <em>and</em> what is not explained by other predictors; this value is always &gt;= the semi-partial correlation. They are <em>not</em> interpretable in the same way as the original coefficients. Partial correlations are computed as the correlations between a DV and each predictor <em>after</em> the influence of all other predictors have been regressed out from that predictor <em>and</em> the DV. Good ref: <a class="reference external" href="https://bit.ly/2GNwXh5">https://bit.ly/2GNwXh5</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>corr_type</strong> (<em>string</em>) – ‘semi’ or ‘partial’</p></li>
<li><p><strong>ztrans_partial_corrs</strong> (<em>bool</em>) – whether to fisher z-transform (arctan) partial correlations before reporting them; default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>partial or semi-partial correlations</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pd.Series</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pymer4-models-lm2-lm2">
<h2><a class="reference internal" href="#pymer4.models.Lm2" title="pymer4.models.Lm2"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymer4.models.Lm2</span></code></a>: Lm2<a class="headerlink" href="#pymer4-models-lm2-lm2" title="Permalink to this headline">¶</a></h2>
<p>Model class for estimating multi-level models in python using the summary-statistics approach</p>
<dl class="py class">
<dt id="pymer4.models.Lm2">
<em class="property">class </em><code class="sig-prename descclassname">pymer4.models.</code><code class="sig-name descname">Lm2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">formula</span></em>, <em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">group</span></em>, <em class="sig-param"><span class="n">family</span><span class="o">=</span><span class="default_value">'gaussian'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/models/Lm2.html#Lm2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.models.Lm2" title="Permalink to this definition">¶</a></dt>
<dd><p>Model class to perform two-stage OLS regression. Practically, this class fits a separate Lm() model to each cluster/group in the data and performs inference on the coefficients of each model (i.e. 1-sample t-test per coefficient). The results from this second level regression are reported. This is an alternative to using Lmer, as it implicitly allows intercept and slopes to vary by group, however with no prior/smoothing/regularization on the random effects. See <a class="reference external" href="https://bit.ly/2SwHhQU">https://bit.ly/2SwHhQU</a> and Gelman (2005). This approach maybe less preferable to Lmer if the number of observations per group are few, but the number of groups is large, in which case the 1st-level estimates are much noisier and are not smoothed/regularized as in Lmer. It maybe preferable when a “maximal” rfx Lmer model is not estimable. Formula specification works just like in R based on columns of a dataframe. Formulae are parsed by patsy which makes it easy to utilize specific columns as factors. This is <strong>different</strong> from Lmer. See patsy for more information on the different use cases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>formula</strong> (<em>str</em>) – Complete lm-style model formula</p></li>
<li><p><strong>data</strong> (<em>pd.DataFrame</em>) – input data</p></li>
<li><p><strong>family</strong> (<em>string</em>) – what distribution family (i.e.) link function to use for the generalized model; default is gaussian (linear model)</p></li>
<li><p><strong>group</strong> (<em>list/string</em>) – the grouping variable to use to run the 1st-level regression; if a list is provided will run multiple levels feeding the coefficients from the previous level into the subsequent level</p></li>
</ul>
</dd>
<dt class="field-even">Variables</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>fitted</strong> (<em>bool</em>) – whether model has been fit</p></li>
<li><p><strong>formula</strong> (<em>str</em>) – model formula</p></li>
<li><p><strong>data</strong> (<em>pandas.core.frame.DataFrame</em>) – model copy of input data</p></li>
<li><p><strong>grps</strong> (<em>dict</em>) – groups and number of observations per groups recognized by lmer</p></li>
<li><p><strong>AIC</strong> (<em>float</em>) – model akaike information criterion</p></li>
<li><p><strong>logLike</strong> (<em>float</em>) – model Log-likelihood</p></li>
<li><p><strong>family</strong> (<em>string</em>) – model family</p></li>
<li><p><strong>warnings</strong> (<em>list</em>) – warnings output from Python</p></li>
<li><p><strong>fixef</strong> (<em>pd.DataFrame</em>) – cluster-level parameters</p></li>
<li><p><strong>coefs</strong> (<em>pd.DataFrame</em>) – model summary table of population parameters</p></li>
<li><p><strong>residuals</strong> (<em>numpy.ndarray</em>) – model residuals</p></li>
<li><p><strong>fits</strong> (<em>numpy.ndarray</em>) – model fits/predictions</p></li>
<li><p><strong>se_type</strong> (<em>string</em>) – how standard errors are computed</p></li>
<li><p><strong>sig_type</strong> (<em>string</em>) – how inference is performed</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="pymer4.models.Lm2.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">robust</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">conf_int</span><span class="o">=</span><span class="default_value">'standard'</span></em>, <em class="sig-param"><span class="n">permute</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">perm_on</span><span class="o">=</span><span class="default_value">'t-stat'</span></em>, <em class="sig-param"><span class="n">rank</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">n_boot</span><span class="o">=</span><span class="default_value">500</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">n_lags</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">to_corrs</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ztrans_corrs</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">cluster</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/models/Lm2.html#Lm2.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.models.Lm2.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a variety of second-level OLS models; all 1st-level models are standard OLS. By default will fit a model that makes parametric assumptions (under a t-distribution) replicating the output of software like R. 95% confidence intervals (CIs) are also estimated parametrically by default. However, empirical bootstrapping can also be used to compute CIs, which will resample with replacement from the first level regression estimates and uses these CIs to perform inference unless permutation tests are requested. Permutation testing  will perform a one-sample sign-flipped permutation test on the estimates directly (perm_on=’coef’) or the t-statistic (perm_on=’t-stat’). Permutation is a bit different than Lm which always permutes based on the t-stat.</p>
<p>Heteroscedasticity robust standard errors can also be computed, but these are applied at the second-level, <em>not</em> at the first level. See the Lm() documentatation for more information about robust standard errors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>robust</strong> (<em>bool/str</em>) – whether to use heteroscedasticity robust s.e. and optionally which estimator type to use (‘hc0’,’hc3’,’hac’,’cluster’). If robust = True, default robust estimator is ‘hc0’; default False</p></li>
<li><p><strong>conf_int</strong> (<em>str</em>) – whether confidence intervals should be computed through bootstrap (‘boot’) or assuming a t-distribution (‘standard’); default ‘standard’</p></li>
<li><p><strong>permute</strong> (<em>int</em>) – if non-zero, computes parameter significance tests by permuting t-stastics rather than parametrically; works with robust estimators</p></li>
<li><p><strong>perm_on</strong> (<em>str</em>) – permute based on a null distribution of the ‘coef’ of first-level estimates or the ‘t-stat’ of first-level estimates; default ‘t-stat’</p></li>
<li><p><strong>rank</strong> (<em>bool</em>) – convert all predictors and dependent variable to ranks before estimating model; default False</p></li>
<li><p><strong>to_corrs</strong> (<em>bool/string</em>) – for each first level model estimate a semi-partial or partial correlations instead of betas and perform inference over these partial correlation coefficients. <em>note</em> this is different than Lm(); default False</p></li>
<li><p><strong>ztrans_corrs</strong> (<em>bool</em>) – whether to fisher-z transform (arcsin) first-level correlations before running second-level model. Ignored if to_corrs is False; default True</p></li>
<li><p><strong>summarize</strong> (<em>bool</em>) – whether to print a model summary after fitting; default True</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – whether to print which model, standard error, confidence interval, and inference type are being fitted</p></li>
<li><p><strong>n_boot</strong> (<em>int</em>) – how many bootstrap resamples to use for confidence intervals (ignored unless conf_int=’boot’)</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – number of cores for parallelizing bootstrapping or permutations; default 1</p></li>
<li><p><strong>n_lags</strong> (<em>int</em>) – number of lags for robust estimator type ‘hac’ (ignored unless robust=’hac’); default 1</p></li>
<li><p><strong>cluster</strong> (<em>str</em>) – column name identifying clusters/groups for robust estimator type ‘cluster’ (ignored unless robust=’cluster’)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>R style summary() table</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pymer4.models.Lm2.plot_summary">
<code class="sig-name descname">plot_summary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">figsize</span><span class="o">=</span><span class="default_value">12, 6</span></em>, <em class="sig-param"><span class="n">error_bars</span><span class="o">=</span><span class="default_value">'ci'</span></em>, <em class="sig-param"><span class="n">ranef</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">axlim</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ranef_alpha</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">coef_fmt</span><span class="o">=</span><span class="default_value">'o'</span></em>, <em class="sig-param"><span class="n">orient</span><span class="o">=</span><span class="default_value">'v'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/models/Lm2.html#Lm2.plot_summary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.models.Lm2.plot_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a forestplot overlaying estimated coefficients with first-level effects. By default display the 95% confidence intervals computed during fitting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>error_bars</strong> (<em>str</em>) – one of ‘ci’ or ‘se’ to change which error bars are plotted; default ‘ci’</p></li>
<li><p><strong>ranef</strong> (<em>bool</em>) – overlay BLUP estimates on figure; default True</p></li>
<li><p><strong>axlim</strong> (<em>tuple</em>) – lower and upper limit of plot; default min and max of BLUPs</p></li>
<li><p><strong>ranef_alpha</strong> (<em>float</em>) – opacity of random effect points; default .5</p></li>
<li><p><strong>coef_fmt</strong> (<em>str</em>) – matplotlib marker style for population coefficients</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>matplotlib axis handle</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>plt.axis</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pymer4.models.Lm2.summary">
<code class="sig-name descname">summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/models/Lm2.html#Lm2.summary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.models.Lm2.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Summarize the output of a fitted model.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>R/statsmodels style summary</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pd.DataFrame</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pymer4-simulate-simulation-functions">
<h2><a class="reference internal" href="#module-pymer4.simulate" title="pymer4.simulate"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymer4.simulate</span></code></a>: Simulation Functions<a class="headerlink" href="#pymer4-simulate-simulation-functions" title="Permalink to this headline">¶</a></h2>
<p>Functions for generating data for use with various model types</p>
<span class="target" id="module-pymer4.simulate"></span><dl class="py function">
<dt id="pymer4.simulate.easy_multivariate_normal">
<code class="sig-prename descclassname">pymer4.simulate.</code><code class="sig-name descname">easy_multivariate_normal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_obs</span></em>, <em class="sig-param"><span class="n">num_features</span></em>, <em class="sig-param"><span class="n">corrs</span></em>, <em class="sig-param"><span class="n">mu</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">sigma</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">forcePSD</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">return_new_corrs</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">nit</span><span class="o">=</span><span class="default_value">100</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/simulate.html#easy_multivariate_normal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.simulate.easy_multivariate_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to more easily generate multivariate normal samples provided a correlation matrix or list of correlations (upper triangle of correlation matrix) instead of a covariance matrix. Defaults to returning approximately standard normal (mu = 0; sigma = 1) variates. Unlike numpy, if the desired correlation matrix is not positive-semi-definite, will by default issue a warning and find the nearest PSD correlation matrix and generate data with this matrix. This new matrix can optionally be returned used the return_new_corrs argument.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_obs</strong> (<em>int</em>) – number of observations/samples to generate (rows)</p></li>
<li><p><strong>corrs</strong> (<em>ndarray/list/float</em>) – num_features x num_features 2d array, flattend numpy array of length (num_features * (num_features-1)) / 2, or scalar for same correlation on all off-diagonals</p></li>
<li><p><strong>num_features</strong> (<em>int</em>) – number of features/variables/dimensions to generate (columns)</p></li>
<li><p><strong>mu</strong> (<em>float/list</em>) – mean of each feature across observations; default 0.0</p></li>
<li><p><strong>sigma</strong> (<em>float/list</em>) – sd of each feature across observations; default 1.0</p></li>
<li><p><strong>forcePD</strong> (<em>bool</em>) – whether to find and use a new correlation matrix if the requested one is not positive semi-definite; default False</p></li>
<li><p><strong>return_new_corrs</strong> (<em>bool</em>) – return the nearest correlation matrix that is positive semi-definite used to generate data; default False</p></li>
<li><p><strong>nit</strong> (<em>int</em>) – number of iterations to search for the nearest positive-semi-definite correlation matrix is the requested correlation matrix is not PSD; default 100</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>2d numpy array of correlated data organized as num_obs x num_features</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pymer4.simulate.simulate_lm">
<code class="sig-prename descclassname">pymer4.simulate.</code><code class="sig-name descname">simulate_lm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_obs</span></em>, <em class="sig-param"><span class="n">num_coef</span></em>, <em class="sig-param"><span class="n">coef_vals</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">corrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mus</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">sigmas</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">noise_params</span><span class="o">=</span><span class="default_value">0, 1</span></em>, <em class="sig-param"><span class="n">family</span><span class="o">=</span><span class="default_value">'gaussian'</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/simulate.html#simulate_lm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.simulate.simulate_lm" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to quickly simulate a regression model dataset, with continuous predictors.
Provided a number of observations, number of coefficients, and optionally correlations between predictors, means, and standard deviations of predictors, returns a pandas dataframe with simulated data that can be used to estimate a linear regression using Lm(). Using the family=’binomial’ argument can generate discrete dependent variable values for use with logistic regression.</p>
<p>Defaults to returning standard normal (mu = 0; sigma = 1) predictors with no explicit correlations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_obs</strong> (<em>int</em>) – number of total observations, i.e. rows of data</p></li>
<li><p><strong>num_coef</strong> (<em>int</em>) – number of coefficients/regressors, i.e. columns of data</p></li>
<li><p><strong>coef_vals</strong> (<em>list</em><em>,</em><em>optional</em>) – “true” values of coefficients to generate data. If not provided will be randomly generated. Must include a coefficient for the intercept as well (i.e. mean of data)</p></li>
<li><p><strong>corrs</strong> (<em>ndarray</em><em>,</em><em>list</em><em>,</em><em>float</em>) – correlations between coefficients provided as 2d num_coef x num_coef, 1d flattend numpy array/list of length (num_features * (num_features-1)) / 2, or a float to be treated as the same correlation between all coefficients</p></li>
<li><p><strong>mus</strong> (<em>float/list/ndarray</em>) – means of columns of predictors</p></li>
<li><p><strong>sigmas</strong> (<em>float/list/ndarray</em>) – stds of columns of predictors</p></li>
<li><p><strong>noise_params</strong> (<em>tup</em><em>, </em><em>optional</em>) – mean and std of noise added to simulated data</p></li>
<li><p><strong>family</strong> (<em>str</em>) – distribution family for the dependent variable. Currently only ‘gaussian’ (continuous DV) or ‘binomial’ (discrete DV) are available.</p></li>
<li><p><strong>seed</strong> (<em>int</em>) – seed for reproducible random number generation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>data</strong> (<em>pd.DataFrame</em>): dataframe organized as num_obs x num_coef</p></li>
<li><p><strong>coefs</strong> (<em>np.array</em>): ground-truth coefficient values</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Multiple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pymer4.simulate.simulate_lmm">
<code class="sig-prename descclassname">pymer4.simulate.</code><code class="sig-name descname">simulate_lmm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_obs</span></em>, <em class="sig-param"><span class="n">num_coef</span></em>, <em class="sig-param"><span class="n">num_grps</span></em>, <em class="sig-param"><span class="n">coef_vals</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">corrs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grp_sigmas</span><span class="o">=</span><span class="default_value">0.25</span></em>, <em class="sig-param"><span class="n">mus</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">sigmas</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">noise_params</span><span class="o">=</span><span class="default_value">0, 1</span></em>, <em class="sig-param"><span class="n">family</span><span class="o">=</span><span class="default_value">'gaussian'</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/simulate.html#simulate_lmm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.simulate.simulate_lmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to quickly simulate a multi-level regression model dataset, with continuous predictors.
Provided a number of observations, number of coefficients, number of groups/clusters,
and optionally correlations between predictors, means, and standard deviations of predictors,
returns a pandas dataframe with simulated data that can be used to estimate a multi-level model using Lmer(). Using the family=’binomial’ argument can generate discrete dependent variable values for use with logistic multi-level models.</p>
<p>Defaults to returning standard normal (mu = 0; sigma = 1) predictors with no explicit correlations and low variance between
groups (sigma = .25).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_obs</strong> (<em>int</em>) – number of observations per cluster/stratum/group</p></li>
<li><p><strong>num_coef</strong> (<em>int</em>) – number of coefficients/regressors, i.e. columns of data</p></li>
<li><p><strong>num_grps</strong> (<em>int</em>) – number of cluster/stratums/groups</p></li>
<li><p><strong>coef_vals</strong> (<em>list</em><em>,</em><em>optional</em>) – “true” values of coefficients to generate data. If not provided will be randomly generated. Must include a coefficient for the intercept as well (i.e. mean of data)</p></li>
<li><p><strong>corrs</strong> (<em>ndarray</em><em>,</em><em>list</em><em>,</em><em>float</em>) – correlations between coefficients provided as 2d num_coef x num_coef, 1d flattend numpy array/list of length (num_features * (num_features-1)) / 2, or a float to be treated</p></li>
<li><p><strong>the same correlation between all coefficients</strong> (<em>as</em>) – </p></li>
<li><p><strong>grp_sigmas</strong> (<em>int</em><em> or </em><em>list</em>) – grp level std around population coefficient values; can be a single value in which case same std is applied around all coefficients or a list for different std; default .25</p></li>
<li><p><strong>mus</strong> (<em>float/list/ndarray</em>) – means of columns of predictors</p></li>
<li><p><strong>sigmas</strong> (<em>float/list/ndarray</em>) – stds of columns of predictors</p></li>
<li><p><strong>noise_params</strong> (<em>tup</em><em>, </em><em>optional</em>) – mean and std of noise added to each group’s simulated data</p></li>
<li><p><strong>family</strong> (<em>str</em>) – distribution family for the dependent variable. Currently only ‘gaussian’ (continuous DV) or ‘binomial’ (discrete DV) are available.</p></li>
<li><p><strong>seed</strong> (<em>int</em>) – seed for reproducible random number generation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>data</strong> (<em>pd.DataFrame</em>): dataframe organized as num_obs x num_coef</p></li>
<li><p><strong>blups</strong> (<em>pd.DataFrame</em>): ground-truth group/cluster level coefficients, organized as num_grps x num_coef (i.e. BLUPs)</p></li>
<li><p><strong>coefs</strong> (<em>np.array</em>): ground-truth population-level coefficients</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Multiple</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="pymer4-stats-statistics-functions">
<h2><a class="reference internal" href="#module-pymer4.stats" title="pymer4.stats"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymer4.stats</span></code></a>: Statistics Functions<a class="headerlink" href="#pymer4-stats-statistics-functions" title="Permalink to this headline">¶</a></h2>
<p>General purpose functions for various parametric and non-parametric statistical routines</p>
<span class="target" id="module-pymer4.stats"></span><dl class="py function">
<dt id="pymer4.stats.boot_func">
<code class="sig-prename descclassname">pymer4.stats.</code><code class="sig-name descname">boot_func</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">func</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">func_args</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">paired</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">n_boot</span><span class="o">=</span><span class="default_value">500</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/stats.html#boot_func"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.stats.boot_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Bootstrap an arbitrary function by resampling from x and y independently or jointly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>list-like</em>) – list of values for first group</p></li>
<li><p><strong>y</strong> (<em>list-like</em>) – list of values for second group; optional</p></li>
<li><p><strong>function</strong> (<em>callable</em>) – function that accepts x or y</p></li>
<li><p><strong>paired</strong> (<em>bool</em>) – whether to resample x and y jointly or independently</p></li>
<li><p><strong>n_boot</strong> (<em>int</em>) – number of bootstrap iterations</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – number of parallel cores; default 1</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>original_stat</strong> (<em>float</em>): function result with given data</p></li>
<li><p><strong>ci</strong> (<em>np.array</em>): lower and upper bounds of 95% confidence intervals</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Multiple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pymer4.stats.cohens_d">
<code class="sig-prename descclassname">pymer4.stats.</code><code class="sig-name descname">cohens_d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">paired</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">n_boot</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">equal_var</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">value</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/stats.html#cohens_d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.stats.cohens_d" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Cohen’s d for one or two samples (paired or independent). For paired samples Cohen’s Dz is computed (ref: <a class="reference external" href="https://bit.ly/2J54P61">https://bit.ly/2J54P61</a>). If x and y are not the same size this will use the same pooled SD calculation in Welch’s ttest to account for unequal variances. Unequal variance calculation will almost always produce a <em>smaller</em> estimate than the standard formula, except as the variance of the group with fewer observations increases. In that case, this estimate can be <em>larger</em> than the standard formula. This can be turned off with the equal_var=True argument. Percentile boot-strapped confidence intervals can also be returned</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>list-like</em>) – array or list of observations from first group</p></li>
<li><p><strong>y</strong> (<em>list-like</em>) – array or list of observations from second group or second set of observations from the same group; optional</p></li>
<li><p><strong>paired</strong> (<em>bool</em>) – whether to treat x any y (if provided) as paired or independent</p></li>
<li><p><strong>n_boot</strong> (<em>int</em>) – number of bootstrap samples to run; set to 0 to skip computing</p></li>
<li><p><strong>equal_var</strong> (<em>bool</em>) – should we pool standard deviation as in Welch’s t-test</p></li>
<li><p><strong>value</strong> (<em>float</em>) – a value to see if the effect size is bigger than; <cite>eff size - value</cite> will be computed; default 0</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – number of parallel cores to use for bootstraping; default 1</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> or </em><em>None</em>) – numerical seed for reproducibility of bootstrapping</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>effect_size</strong> (<em>float</em>): cohen’s d</p></li>
<li><p><strong>ci</strong> (<em>np.array</em>): lower and upper bounds of 95% bootstrapped confidence intervals; optional</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Multiple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pymer4.stats.discrete_inverse_logit">
<code class="sig-prename descclassname">pymer4.stats.</code><code class="sig-name descname">discrete_inverse_logit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/stats.html#discrete_inverse_logit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.stats.discrete_inverse_logit" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a discretized inverse logit transform to an array of values. Useful for converting normally distributed values to binomial classes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arr</strong> (<em>np.array</em>) – 1d numpy array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>transformed values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pymer4.stats.perm_test">
<code class="sig-prename descclassname">pymer4.stats.</code><code class="sig-name descname">perm_test</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">stat</span><span class="o">=</span><span class="default_value">'tstat'</span></em>, <em class="sig-param"><span class="n">n_perm</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">equal_var</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">tails</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">return_dist</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/stats.html#perm_test"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.stats.perm_test" title="Permalink to this definition">¶</a></dt>
<dd><p>General purpose permutation test between two samples. Can handle a wide varierty of permutation tests including ttest, paired ttest, mean diff test, cohens d, pearson r, spearman r.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>list-like</em>) – array or list of observations from first group</p></li>
<li><p><strong>y</strong> (<em>list-like</em>) – array or list of observations from second group</p></li>
<li><p><strong>stat</strong> (<em>string</em>) – one of [‘tstat’, ‘tstat-paired’, ‘mean’, ‘cohensd’, ‘pearsonr’, ‘spearmanr’]; ‘mean’ will just compute permutations on the difference between the mean of x and mean of y. Useful if statistics are precomputed (e.g. x and y contain correlation values, or t-stats).</p></li>
<li><p><strong>n_perm</strong> (<em>int</em>) – number of permutations; set to 0 to return parametric results</p></li>
<li><p><strong>equal_var</strong> (<em>bool</em>) – should assume equal variances for tstat and cohensd</p></li>
<li><p><strong>tails</strong> (<em>int</em>) – perform one or two-tailed p-value computations; default 2</p></li>
<li><p><strong>return_dists</strong> (<em>bool</em>) – return permutation distribution</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em>) – number of parallel cores to use for bootstraping; default 1</p></li>
<li><p><strong>seed</strong> (<em>int</em>) – for reproducing results</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>original_stat</strong> (<em>float</em>): the original statistic</p></li>
<li><p><strong>perm_p_val</strong> (<em>float</em>): the permuted p-value</p></li>
<li><p><strong>perm_dist</strong> (<em>np.array</em>): array of permuted statistic; optional</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Multiple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pymer4.stats.rsquared">
<code class="sig-prename descclassname">pymer4.stats.</code><code class="sig-name descname">rsquared</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">res</span></em>, <em class="sig-param"><span class="n">has_constant</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/stats.html#rsquared"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.stats.rsquared" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the R^2, coefficient of determination. This statistic is a ratio of “explained variance” to “total variance”</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>np.ndarray</em>) – 1d array of dependent variable</p></li>
<li><p><strong>res</strong> (<em>np.ndarray</em>) – 1d array of residuals</p></li>
<li><p><strong>has_constant</strong> (<em>bool</em>) – whether the fitted model included a constant (intercept)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>coefficient of determination</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pymer4.stats.rsquared_adj">
<code class="sig-prename descclassname">pymer4.stats.</code><code class="sig-name descname">rsquared_adj</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">nobs</span></em>, <em class="sig-param"><span class="n">df_res</span></em>, <em class="sig-param"><span class="n">has_constant</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/stats.html#rsquared_adj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.stats.rsquared_adj" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the adjusted R^2, coefficient of determination.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>float</em>) – rsquared value</p></li>
<li><p><strong>nobs</strong> (<em>int</em>) – number of observations the model was fit on</p></li>
<li><p><strong>df_res</strong> (<em>int</em>) – degrees of freedom of the residuals (nobs - number of model params)</p></li>
<li><p><strong>has_constant</strong> (<em>bool</em>) – whether the fitted model included a constant (intercept)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>adjusted coefficient of determination</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pymer4.stats.tost_equivalence">
<code class="sig-prename descclassname">pymer4.stats.</code><code class="sig-name descname">tost_equivalence</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">lower</span></em>, <em class="sig-param"><span class="n">upper</span></em>, <em class="sig-param"><span class="n">paired</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">equal_var</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">n_perm</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">n_boot</span><span class="o">=</span><span class="default_value">5000</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/stats.html#tost_equivalence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.stats.tost_equivalence" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to perform equivalence testing using TOST: two-one-sided-tests (Lakens et al, 2018). This works by defining a lower and upper bound of an “equivalence” range for the mean difference between x and y. This is a user-defined range that one might not feel is a particularly meangingful mean difference; conceptually similar to the Bayesian “region of practical equivalence (rope).” Specifically this uses, two one-sided t-tests against and lower and upper seperately to find out whether lower &lt; mean diff &lt; higher. n_perm only controls the permutation for the original two-sided test.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>list-like</em>) – array or list of observations from first group</p></li>
<li><p><strong>y</strong> (<em>list-like</em>) – array or list of observations from second group</p></li>
<li><p><strong>lower</strong> (<em>float</em>) – lower bound of equivalence region</p></li>
<li><p><strong>upper</strong> (<em>float</em>) – upper bound of equivalence region</p></li>
<li><p><strong>equal_var</strong> (<em>bool</em>) – should assume equal variances for t-stat and effect size calcs</p></li>
<li><p><strong>n_perm</strong> (<em>int</em>) – number of times to permute groups; set to 0 to turn off</p></li>
<li><p><strong>n_boot</strong> (<em>int</em>) – number of bootstrap samples for confidence intervals</p></li>
<li><p><strong>plot</strong> (<em>bool</em>) – return an equivalence plot depicting where the mean difference and 95% CIs fall relative to the equivalence range</p></li>
<li><p><strong>return_dists</strong> (<em>bool</em>) – optionally return the permuted distributions</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a dictionary of TOST results</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pymer4.stats.vif">
<code class="sig-prename descclassname">pymer4.stats.</code><code class="sig-name descname">vif</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em>, <em class="sig-param"><span class="n">has_intercept</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">exclude_intercept</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">5.0</span></em>, <em class="sig-param"><span class="n">check_only</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/stats.html#vif"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.stats.vif" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute variance inflation factor amongst columns of a dataframe to be used as a design matrix. Uses the same method as Matlab and R (diagonal elements) of the inverted correlation matrix. Prints a warning if any vifs are &gt;= to tol. If check_only is true it will only return a 1 if any vifs are higher than tol.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>df</strong> (<em>pandas.DataFrame</em>) – dataframe of design matrix output from patsy</p></li>
<li><p><strong>has_intercept</strong> (<em>bool</em>) – whether the first column of the dataframe is the intercept</p></li>
<li><p><strong>exclude_intercept</strong> (<em>bool</em>) – exclude intercept from computation and assumed intercept is the first column; default True</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – tolerance check to print warning if any vifs exceed this value</p></li>
<li><p><strong>check_only</strong> (<em>bool</em>) – restrict return to a dictionary of vifs that exceed tol only rather than all; default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dictionary with keys as column names and values as vifs</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pymer4.stats.welch_dof">
<code class="sig-prename descclassname">pymer4.stats.</code><code class="sig-name descname">welch_dof</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/stats.html#welch_dof"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.stats.welch_dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute adjusted dof via Welch-Satterthwaite equation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>np.ndarray</em>) – 1d numpy array</p></li>
<li><p><strong>y</strong> (<em>np.ndarray</em>) – 1d numpy array</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>degrees of freedom</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="pymer4-utils-utility-functions">
<h2><a class="reference internal" href="#module-pymer4.utils" title="pymer4.utils"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymer4.utils</span></code></a>: Utility Functions<a class="headerlink" href="#pymer4-utils-utility-functions" title="Permalink to this headline">¶</a></h2>
<p>Miscellaneous helper functions</p>
<span class="target" id="module-pymer4.utils"></span><dl class="py function">
<dt id="pymer4.utils.R2con">
<code class="sig-prename descclassname">pymer4.utils.</code><code class="sig-name descname">R2con</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/utils.html#R2con"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.utils.R2con" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert R-flavored contrast matrix to intepretable contrasts as would be specified by user. Reference: <a class="reference external" href="https://goo.gl/E4Mms2">https://goo.gl/E4Mms2</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arr</strong> (<em>np.ndarry</em>) – 2d contrast matrix output from R’s contrasts() function.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>2d array organized as contrasts X factor levels</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pymer4.utils.con2R">
<code class="sig-prename descclassname">pymer4.utils.</code><code class="sig-name descname">con2R</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span></em>, <em class="sig-param"><span class="n">names</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/utils.html#con2R"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.utils.con2R" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert human-readable contrasts into a form that R requires. Works like the make.contrasts() function from the gmodels package, in that it will auto-solve for the remaining orthogonal k-1 contrasts if fewer than k-1 contrasts are specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> (<em>np.ndarray</em>) – 1d or 2d numpy array with each row reflecting a unique contrast and each column a factor level</p></li>
<li><p><strong>names</strong> (<em>list/np.ndarray</em>) – optional list of contrast names which will cast the return object as a dataframe</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A 2d numpy array or dataframe useable with the contrasts argument of glmer</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pymer4.utils.get_resource_path">
<code class="sig-prename descclassname">pymer4.utils.</code><code class="sig-name descname">get_resource_path</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/utils.html#get_resource_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.utils.get_resource_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Get path sample data directory.</p>
</dd></dl>

<dl class="py function">
<dt id="pymer4.utils.isPSD">
<code class="sig-prename descclassname">pymer4.utils.</code><code class="sig-name descname">isPSD</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mat</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-08</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/utils.html#isPSD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.utils.isPSD" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if matrix is positive-semi-definite by virtue of all its eigenvalues being &gt;= 0. The cholesky decomposition does not work for edge cases because np.linalg.cholesky fails on matrices with exactly 0 valued eigenvalues, whereas in Matlab this is not true, so that method appropriate. Ref: <a class="reference external" href="https://goo.gl/qKWWzJ">https://goo.gl/qKWWzJ</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mat</strong> (<em>np.ndarray</em>) – 2d numpy array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>whether matrix is postive-semi-definite</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pymer4.utils.nearestPSD">
<code class="sig-prename descclassname">pymer4.utils.</code><code class="sig-name descname">nearestPSD</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mat</span></em>, <em class="sig-param"><span class="n">nit</span><span class="o">=</span><span class="default_value">100</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/utils.html#nearestPSD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.utils.nearestPSD" title="Permalink to this definition">¶</a></dt>
<dd><p>Higham (2000) algorithm to find the nearest positive semi-definite matrix that minimizes the Frobenius distance/norm. Statsmodels using something very similar in corr_nearest(), but with spectral SGD to search for a local minima. Reference: <a class="reference external" href="https://goo.gl/Eut7UU">https://goo.gl/Eut7UU</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mat</strong> (<em>np.ndarray</em>) – 2d numpy array</p></li>
<li><p><strong>nit</strong> (<em>int</em>) – number of iterations to run algorithm; more iterations improves accuracy but increases computation time.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>closest positive-semi-definite 2d numpy array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pymer4.utils.pandas2R">
<code class="sig-prename descclassname">pymer4.utils.</code><code class="sig-name descname">pandas2R</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/utils.html#pandas2R"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.utils.pandas2R" title="Permalink to this definition">¶</a></dt>
<dd><p>Local conversion of pandas dataframe to R dataframe as recommended by rpy2</p>
</dd></dl>

<dl class="py function">
<dt id="pymer4.utils.upper">
<code class="sig-prename descclassname">pymer4.utils.</code><code class="sig-name descname">upper</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mat</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/utils.html#upper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.utils.upper" title="Permalink to this definition">¶</a></dt>
<dd><p>Return upper triangle of matrix. Useful for grabbing unique values from a symmetric matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mat</strong> (<em>np.ndarray</em>) – 2d numpy array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>1d numpy array of values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="pymer4-io-save-load-functions">
<h2><a class="reference internal" href="#module-pymer4.io" title="pymer4.io"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymer4.io</span></code></a>: Save/Load Functions<a class="headerlink" href="#pymer4-io-save-load-functions" title="Permalink to this headline">¶</a></h2>
<p>Functions for persisting models to disk</p>
<span class="target" id="module-pymer4.io"></span><dl class="py function">
<dt id="pymer4.io.load_model">
<code class="sig-prename descclassname">pymer4.io.</code><code class="sig-name descname">load_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filepath</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/io.html#load_model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.io.load_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for loading pymer4 models. A file path ending in .h5 or .hdf5 should be provided. For Lmer models an additional filepath.robj should be located in the same directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>pymer4.models</em>) – an instance of a pymer4 model</p></li>
<li><p><strong>filepath</strong> (<em>str</em>) – full filepath string ending with .h5 or .hd5f</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pymer4.io.save_model">
<code class="sig-prename descclassname">pymer4.io.</code><code class="sig-name descname">save_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">filepath</span></em>, <em class="sig-param"><span class="n">compression</span><span class="o">=</span><span class="default_value">'zlib'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymer4/io.html#save_model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymer4.io.save_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for saving pymer4 models. All models are saved in .h5 or .hdf5 files so filepath extensions should include this. For Lmer models an additional filepath.robj file will be created to retain all R objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>pymer4.models</em>) – an instance of a pymer4 model</p></li>
<li><p><strong>filepath</strong> (<em>str</em>) – full filepath string ending with .h5 or .hd5f</p></li>
<li><p><strong>compression</strong> (<em>string</em>) – what kind of compression to use; zlib is the default which should be universally accessible, but for example ‘blosc’ will be faster and produce smaller files. See more here: <a class="reference external" href="https://bit.ly/33x9JD7">https://bit.ly/33x9JD7</a></p></li>
<li><p><strong>kwargs</strong> – optional keyword arguments to deepdish.io.save</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2020, Eshin Jolly.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.2.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>